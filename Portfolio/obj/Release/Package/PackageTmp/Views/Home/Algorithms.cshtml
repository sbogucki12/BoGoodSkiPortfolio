
@{
    ViewBag.Title = "Algorithms";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="row">
    <div class="col-md-12"></div>
</div>

<div class="row">
    <div class="col-md-3">
        <p></p>
    </div>
    <div class="col-md-6"  id="algoHeader">
        <h1>Algorithms.</h1>
    </div>
    <div class="col-md-3">
        <p></p>
    </div>
</div>

<div class="row">
    <div class="col-md-12">
        <p></p>
    </div>
</div>

<div class="row">
    <div class="col-md-3">
        <p></p>
    </div>
    <div class="col-md-6" id="algoText">
        <h4>Algorithms are fun.</h4>
        <h4>And also fun...damental to development, whether for software, the web, or anywhere or anything else.</h4>
        <p>I like to practice writing algorithms.  I like to call this "drilling algorithms."</p>
        <p>So, here, I will post pics of algorithms as I drill them.</p>
        <p>Enjoy!</p>
    </div>
    <div class="col-md-3">
        <p></p>
    </div>
</div>

<div class="row">
    <div class="col-md-3" id="algoDiscBlank">
    </div>
    <div class="col-md-6" id="algoDiscussion">
        <h3><i>Why is it important to understand how algorithms work?</i>
        </h3>
        <p>Many reasons. But, on a very basic level, one good one is because algorithms make demands on the computing system in time and space.</p>
        <p>A mathematical concept, <a href="https://en.wikipedia.org/wiki/Big_O_notation" target="_blank">Big O Notation</a>, is important in computer science. I struggle to articulate Big O Notation with specificity. Though, in consideration of space and time complexity, I can provide examples.
        </p>
        <p>So far as an algorithm’s space requirement goes, consider a sorting algorithm that needs to create additional temporary arrays in order to complete its execution. Each new array takes up computing space in memory, though potentially only temporarily, at large scale, the space requirement is not insignificant. Consider an alternate algorithm that completes the same sorting task but does so without creating additional arrays during its execution. This second algorithm would require less space in memory than the first.</p>
        <p>A good example of an algorithm’s potential execution time was described by <a href="https://twitter.com/davidjmalan" target="_blank">David J. Malan</a> via the <a href="https://www.edx.org/course/introduction-computer-science-harvardx-cs50x" target="_blank">Harvard CS50x course</a>. Consider a phone book with 1,000 names, sorted alphabetically. Let’s say that you wanted to find a name that begins with “M”. One way to find this name would be to start at the beginning of the phone book and check every single name until you reached the targeted name, beginning with “M”. This means that if the targeted name had begun with “Z”, the search could have taken nearly 1,000 steps. This technique is the “<a href="https://en.wikipedia.org/wiki/Brute-force_search" target="_blank">brute force</a>” method.
        </p>
        <p>An alternative method would be to split the phone book in half and then ask whether the name is in this half of the book, or that half of the book. You then discard the half of the book that does not contain names beginning with the targeted letter. You then ask the same question of the remaining half of the book, splitting it, and discarding one half. You continue this process over and over until you find the targeted name. This second technique is known as a “<a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" target="_blank">divide and conquer</a>” method.
        </p>
        <p>The beauty of the divide and conquer method? Let’s say we add 500 more names to the phone book. In the brute force method, we could potentially have to search 500 more names. With the divide and conquer method, we only need to search 500 / 2 more names, and then, potentially, 250 / 2 more names, etc. So, instead of adding 500 more searches, we’ve only added a handful. So, the divide and conquer method is much more efficient in the time it takes to execute than the brute force method.</p>
        <p>Ultimately, the value in knowing the size and the complexity of your algorithm is to first understand that there are usually many ways to accomplish a task. You can assess the space and time complexity of your algorithm to determine whether it's the most efficient of the many ways to execute the desired action.</p>
        <p><b><i>Whew…</i></b>
        </p>
    </div>
    <div class="col-md-3" id="algoDiscBlank">
    </div>
</div>

<div class="row">
    <div class="col-md-12">
        <p></p>
    </div>
</div>

<div class="row">
    <div class="col-md-4" id="algoBox">
        <p>
            <a href="https://imgur.com/a/n9VpY" target="_blank">
                <img src="~/Content/Images/Algorithms/Bubblesort.JPG" width="300" height="250" alt="Bubblesort"/>
            </a>
        </p>
        <p><b><i>Dec. 4, 2017: </i></b>This is a JavaScript function that takes in an array of integers and displays those integers on the console by value, in descending order. It's my take on "Bubblesort".</p>
    </div>

    <div class="col-md-4" id="algoBox">
        <p>
            <a href="https://imgur.com/R16QZpw" target="_blank">
                <img src="~/Content/Images/Algorithms/mergeSort.JPG" width="300" height="250" alt="MergeSort"/>
            </a>
        </p>
        <p>
            <b><i>Dec. 5, 2017:</i></b> This is a JavaScript function that takes two previously sorted arrays and combines them into a single sorted array. I wish I could take total credit for this code. There is a great website for practicing these sort of challenges called <a href="https://www.interviewcake.com" target="_blank">Interview Cake</a>. Interview Cake provides hints if needed. And, for this one, I needed them! 
        </p>
    </div>

    <div class="col-md-4">
        <p></p>
    </div>
</div>


